<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tower Scavenger Hunt Control Room</title>
  <style>
    :root {
      color-scheme: light dark;
      --bg: #0b132b;
      --panel: rgba(17, 34, 64, 0.92);
      --accent: #5bc0be;
      --accent-soft: rgba(91, 192, 190, 0.1);
      --text: #e0f1ff;
      --text-muted: rgba(224, 241, 255, 0.72);
      --danger: #f67280;
      font-family: "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at top, rgba(91, 192, 190, 0.2), transparent 55%),
        linear-gradient(180deg, rgba(11, 19, 43, 0.96) 0%, rgba(5, 8, 19, 0.98) 100%);
      color: var(--text);
      display: flex;
      justify-content: center;
      padding: 2rem 1.5rem 3rem;
    }

    main {
      width: min(1200px, 100%);
      background: rgba(3, 9, 21, 0.78);
      border: 1px solid rgba(91, 192, 190, 0.25);
      border-radius: 24px;
      backdrop-filter: blur(14px);
      box-shadow: 0 30px 70px -35px black;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-height: calc(100vh - 6rem);
    }

    header {
      padding: 2.5rem clamp(1.5rem, 4vw, 3rem) 2rem;
      background: linear-gradient(135deg, rgba(91, 192, 190, 0.22), rgba(72, 149, 239, 0.08));
      border-bottom: 1px solid rgba(91, 192, 190, 0.18);
    }

    h1 {
      margin: 0;
      font-size: clamp(2rem, 4vw, 2.8rem);
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    header p {
      margin: 0.75rem 0 0;
      max-width: 620px;
      color: var(--text-muted);
      line-height: 1.6;
      font-size: 0.98rem;
    }

    .control-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      padding: 1.5rem clamp(1.5rem, 4vw, 3rem) 1rem;
      align-items: center;
      background: rgba(7, 16, 33, 0.85);
      border-bottom: 1px solid rgba(91, 192, 190, 0.18);
    }

    .progress-panel {
      display: flex;
      gap: 1rem;
      align-items: center;
      flex-wrap: wrap;
    }

    .action-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
    }

    .action-button {
      background: rgba(91, 192, 190, 0.14);
      color: var(--text);
      border: 1px solid rgba(91, 192, 190, 0.4);
      border-radius: 10px;
      padding: 0.55rem 0.95rem;
      font-size: 0.9rem;
      letter-spacing: 0.04em;
      cursor: pointer;
      transition: all 0.18s ease;
    }

    .action-button:hover,
    .action-button:focus-visible {
      outline: none;
      border-color: var(--accent);
      background: rgba(91, 192, 190, 0.24);
      transform: translateY(-1px);
      box-shadow: 0 8px 18px -12px var(--accent);
    }

    .status-message {
      flex-basis: 100%;
      font-size: 0.85rem;
      letter-spacing: 0.04em;
      padding: 0.55rem 0.85rem;
      border-radius: 8px;
      border: 1px solid transparent;
      background: rgba(91, 192, 190, 0.08);
      color: var(--text-muted);
      opacity: 0;
      transform: translateY(-6px);
      transition: opacity 0.22s ease, transform 0.22s ease;
    }

    .status-message.visible {
      opacity: 1;
      transform: translateY(0);
    }

    .status-message.success {
      border-color: rgba(91, 192, 190, 0.55);
      background: rgba(91, 192, 190, 0.18);
      color: var(--text);
    }

    .status-message.error {
      border-color: rgba(246, 114, 128, 0.65);
      background: rgba(246, 114, 128, 0.16);
      color: var(--danger);
    }

    .progress-wrapper {
      width: clamp(200px, 30vw, 360px);
    }

    .progress-label {
      font-size: 0.85rem;
      color: var(--text-muted);
      margin-bottom: 0.25rem;
      display: flex;
      justify-content: space-between;
    }

    .progress-bar {
      appearance: none;
      width: 100%;
      height: 10px;
      border-radius: 6px;
      background: rgba(91, 192, 190, 0.12);
      overflow: hidden;
    }

    .progress-bar::-webkit-progress-bar {
      background: rgba(91, 192, 190, 0.12);
    }

    .progress-bar::-webkit-progress-value {
      background: linear-gradient(90deg, var(--accent) 0%, #68d8d6 100%);
      border-radius: 6px;
    }

    .progress-bar::-moz-progress-bar {
      background: linear-gradient(90deg, var(--accent) 0%, #68d8d6 100%);
      border-radius: 6px;
    }

    .reset-button {
      background: none;
      border: 1px solid rgba(246, 114, 128, 0.6);
      color: var(--danger);
      padding: 0.55rem 0.9rem;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.85rem;
      letter-spacing: 0.04em;
      transition: all 0.18s ease;
    }

    .reset-button:hover,
    .reset-button:focus-visible {
      outline: none;
      background: rgba(246, 114, 128, 0.12);
      border-color: rgba(246, 114, 128, 0.9);
    }

    .stage {
      flex: 1;
      display: grid;
      grid-template-columns: minmax(0, 2.1fr) minmax(220px, 1fr);
      gap: clamp(1.5rem, 4vw, 2.5rem);
      padding: clamp(1.5rem, 5vw, 3rem);
      background: rgba(4, 12, 24, 0.78);
    }

    .puzzle-view {
      border: 1px solid rgba(91, 192, 190, 0.25);
      background: rgba(8, 22, 46, 0.82);
      border-radius: 22px;
      padding: clamp(1.5rem, 4vw, 3rem);
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      min-height: 480px;
      box-shadow: inset 0 0 35px -28px rgba(91, 192, 190, 0.6);
    }

    .puzzle-hero {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .puzzle-hero h2 {
      margin: 0;
      font-size: clamp(2rem, 4vw, 2.8rem);
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .puzzle-meta-line {
      display: flex;
      flex-wrap: wrap;
      gap: 0.65rem;
      font-size: 0.95rem;
      color: var(--text-muted);
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }

    .puzzle-body {
      flex: 1;
      font-size: clamp(1rem, 2.6vw, 1.15rem);
      line-height: 1.7;
      color: var(--text-muted);
      max-width: 70ch;
    }

    .stage-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: center;
    }

    .answer-feedback {
      font-size: 0.85rem;
      letter-spacing: 0.05em;
      color: var(--text-muted);
      min-height: 1.2rem;
    }

    .answer-feedback.success {
      color: var(--accent);
    }

    .answer-feedback.error {
      color: var(--danger);
    }

    .primary-action {
      border: none;
      border-radius: 12px;
      padding: 0.85rem 1.6rem;
      font-size: 1rem;
      letter-spacing: 0.08em;
      font-weight: 600;
      cursor: pointer;
      background: linear-gradient(135deg, var(--accent), #6ff0eb);
      color: #041128;
      box-shadow: 0 15px 32px -20px var(--accent);
      transition: transform 0.18s ease, box-shadow 0.18s ease, filter 0.18s ease;
    }

    .primary-action:hover,
    .primary-action:focus-visible {
      outline: none;
      transform: translateY(-2px);
      box-shadow: 0 18px 36px -18px var(--accent);
      filter: brightness(1.05);
    }

    .secondary-link {
      background: none;
      border: 1px solid rgba(91, 192, 190, 0.4);
      color: var(--accent);
      border-radius: 999px;
      padding: 0.5rem 1.1rem;
      font-size: 0.9rem;
      letter-spacing: 0.05em;
      cursor: pointer;
      transition: border-color 0.18s ease, background 0.18s ease;
    }

    .secondary-link:hover,
    .secondary-link:focus-visible {
      outline: none;
      border-color: var(--accent);
      background: rgba(91, 192, 190, 0.18);
    }

    .progress-track {
      border: 1px solid rgba(91, 192, 190, 0.2);
      background: rgba(5, 16, 35, 0.82);
      border-radius: 20px;
      padding: clamp(1.2rem, 3vw, 2rem);
      display: flex;
      flex-direction: column;
      gap: 1.2rem;
      position: relative;
    }

    .progress-track h3 {
      margin: 0;
      font-size: 1.05rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--text-muted);
    }

    .progress-list {
      display: flex;
      flex-direction: column;
      gap: 0.85rem;
      overflow: auto;
      max-height: min(60vh, 520px);
      padding-right: 0.3rem;
    }

    .progress-item {
      border: 1px solid rgba(91, 192, 190, 0.2);
      border-radius: 14px;
      padding: 0.8rem 1rem;
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 0.75rem;
      align-items: center;
      background: rgba(8, 24, 48, 0.7);
      font-size: 0.92rem;
      letter-spacing: 0.04em;
      transition: border-color 0.18s ease, transform 0.18s ease;
    }

    .progress-content {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .progress-item.active {
      border-color: rgba(91, 192, 190, 0.6);
      background: rgba(18, 44, 72, 0.85);
      box-shadow: 0 20px 40px -28px var(--accent);
      transform: translateX(6px);
    }

    .progress-item.complete {
      border-color: rgba(91, 192, 190, 0.8);
      background: rgba(28, 53, 74, 0.85);
    }

    .progress-index {
      width: 34px;
      height: 34px;
      border-radius: 50%;
      display: grid;
      place-items: center;
      font-weight: 600;
      background: rgba(91, 192, 190, 0.18);
      color: var(--accent);
    }

    .progress-item.complete .progress-index {
      background: var(--accent);
      color: #041128;
    }

    .progress-status {
      font-size: 0.78rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(224, 241, 255, 0.6);
    }

    .progress-status.unlocked {
      color: var(--accent);
    }

    .progress-status.locked {
      color: rgba(224, 241, 255, 0.35);
    }

    .platform-tag {
      font-size: 0.82rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(224, 241, 255, 0.6);
      display: inline-flex;
      gap: 0.4rem;
      align-items: center;
    }

    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(4, 10, 22, 0.8);
      backdrop-filter: blur(10px);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1.5rem;
      z-index: 1000;
    }

    .modal-backdrop[hidden] {
      display: none;
    }

    .modal-dialog {
      background: rgba(6, 18, 40, 0.9);
      border: 1px solid rgba(91, 192, 190, 0.35);
      border-radius: 20px;
      padding: clamp(1.5rem, 4vw, 2.5rem);
      width: min(480px, 100%);
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      color: var(--text);
      box-shadow: 0 30px 80px -45px black;
    }

    .modal-dialog h2 {
      margin: 0;
      font-size: clamp(1.4rem, 4vw, 2rem);
      letter-spacing: 0.1em;
      text-transform: uppercase;
    }

    .modal-dialog p {
      margin: 0;
      color: var(--text-muted);
      line-height: 1.6;
      font-size: 0.95rem;
    }

    .team-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 0.9rem;
    }

    .team-select {
      border: 1px solid rgba(91, 192, 190, 0.4);
      border-radius: 14px;
      padding: 0.85rem 1rem;
      font-size: 1rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--text);
      background: rgba(12, 30, 54, 0.8);
      cursor: pointer;
      transition: transform 0.18s ease, border-color 0.18s ease, background 0.18s ease;
    }

    .team-select:hover,
    .team-select:focus-visible {
      outline: none;
      border-color: var(--accent);
      background: rgba(91, 192, 190, 0.2);
      transform: translateY(-2px);
    }

    .scanner-shell {
      display: grid;
      gap: 1rem;
    }

    .scanner-video {
      width: 100%;
      border-radius: 18px;
      border: 1px solid rgba(91, 192, 190, 0.3);
      background: rgba(3, 9, 21, 0.8);
    }

    .scan-status {
      font-size: 0.9rem;
      color: var(--text-muted);
      letter-spacing: 0.04em;
      min-height: 1.2rem;
    }

    .scan-status.success {
      color: var(--accent);
    }

    .scan-status.error {
      color: var(--danger);
    }

    .manual-entry {
      display: flex;
      gap: 0.75rem;
      align-items: stretch;
      flex-wrap: wrap;
    }

    .manual-entry input {
      flex: 1;
      min-width: 180px;
      border-radius: 12px;
      border: 1px solid rgba(91, 192, 190, 0.3);
      background: rgba(3, 15, 32, 0.72);
      color: var(--text);
      padding: 0.65rem 0.85rem;
      letter-spacing: 0.05em;
      font-size: 0.95rem;
    }

    .manual-entry input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(91, 192, 190, 0.18);
    }


    .footer-note {
      padding: 1rem clamp(1.5rem, 4vw, 3rem) 2.2rem;
      color: rgba(224, 241, 255, 0.55);
      font-size: 0.85rem;
      letter-spacing: 0.04em;
      background: rgba(3, 9, 21, 0.8);
      border-top: 1px solid rgba(91, 192, 190, 0.18);
    }

    @media (max-width: 780px) {
      main {
        border-radius: 0;
        min-height: 100vh;
      }

      .control-bar {
        padding: 1.25rem clamp(1rem, 6vw, 1.75rem);
        gap: 1.25rem;
      }

      .progress-panel {
        width: 100%;
        justify-content: flex-start;
      }

      .progress-wrapper {
        width: 100%;
      }

      .stage {
        display: flex;
        flex-direction: column;
        padding: clamp(1.1rem, 6vw, 1.8rem);
        gap: 1.25rem;
      }

      .puzzle-view {
        min-height: 380px;
        padding: clamp(1.1rem, 5vw, 1.8rem);
      }

      .progress-track {
        padding: clamp(1rem, 5vw, 1.6rem);
        max-height: none;
      }

      .progress-list {
        flex-direction: row;
        overflow-x: auto;
        overflow-y: visible;
        max-height: none;
        gap: 0.75rem;
      }

      .progress-item {
        min-width: 220px;
        grid-template-columns: 1fr;
        gap: 0.5rem;
      }
    }

    @media (max-width: 520px) {
      body {
        padding: 0;
      }

      main {
        border-radius: 0;
      }

      .puzzle-hero h2 {
        font-size: clamp(1.6rem, 8vw, 2rem);
      }

      .stage-actions {
        flex-direction: column;
        align-items: stretch;
      }

      .primary-action,
      .secondary-link {
        width: 100%;
        text-align: center;
      }
    }
  </style>
</head>
<body>
  <main>
    <header>
      <h1>The Tower Scavenger Hunt</h1>
      <p>
        Track your tower run across the basement and eleven upper floors of challenges. As puzzle content is finalized, replace
        the filler text inside
        each floor card. Progress is saved locally with cookies, so you can refresh or return to this page without losing your place.
      </p>
    </header>

    <section class="control-bar">
      <div class="progress-panel">
        <div class="progress-wrapper">
          <div class="progress-label">
            <span id="progressLabel">Hunt Progress</span>
            <span id="progressCount"></span>
          </div>
          <progress id="progressBar" class="progress-bar" value="0" max="11"></progress>
        </div>
      </div>
      <div class="action-buttons">
        <button type="button" class="action-button" id="exportProgress">Copy Progress Code</button>
        <button type="button" class="action-button" id="importProgress">Import Progress</button>
        <button type="button" class="reset-button" id="resetAll">Reset Progress</button>
      </div>
      <div class="status-message" id="statusMessage" role="status" aria-live="polite"></div>
    </section>

    <section class="stage" aria-live="polite">
      <article class="puzzle-view" id="puzzleView">
        <div class="puzzle-hero">
          <h2 id="puzzleTitle">Loading Mission</h2>
          <div class="puzzle-meta-line" id="puzzleMeta"></div>
        </div>
        <div class="puzzle-body" id="puzzleBody"></div>
        <div class="stage-actions">
          <button type="button" class="primary-action" id="scanButton" disabled>Start QR Scan</button>
          <button type="button" class="secondary-link" id="reviewProgress">View Mission Queue</button>
        </div>
        <div class="answer-feedback" id="puzzleFeedback" aria-live="polite"></div>
      </article>
      <aside class="progress-track" id="progressPanel">
        <div class="platform-tag" id="platformTag">Platform: Detecting…</div>
        <h3>Mission Queue</h3>
        <div class="progress-list" id="progressList"></div>
      </aside>
    </section>

    <footer class="footer-note">
      Tip: want to stage new puzzle text? Update the placeholders here and commit the file to GitHub Pages. Cookie storage lasts
      one year and is scoped to this page.
    </footer>
  </main>

  <div class="modal-backdrop" id="teamModal">
    <div class="modal-dialog" role="dialog" aria-modal="true" aria-labelledby="teamModalTitle">
      <h2 id="teamModalTitle">Select Your Team</h2>
      <p>
        Each team tackles the tower floors in a unique sequence. Choose your team to load the proper mission order. Progress saves
        to this device.
      </p>
      <div class="team-grid" id="teamGrid" role="listbox" aria-label="Available teams"></div>
    </div>
  </div>

  <div class="modal-backdrop" id="scannerModal" hidden>
    <div class="modal-dialog" role="dialog" aria-modal="true" aria-labelledby="scannerTitle">
      <div class="scanner-shell">
        <h2 id="scannerTitle">Scan Mission QR</h2>
        <p id="scannerInstruction">Align the QR code inside the frame. We’ll automatically validate the code for this floor.</p>
        <video class="scanner-video" id="scannerVideo" playsinline></video>
        <div class="scan-status" id="scanStatus"></div>
        <div class="manual-entry">
          <input type="text" id="manualCode" placeholder="Enter code manually" autocomplete="off" inputmode="search" />
          <button type="button" class="primary-action" id="submitCode">Submit Code</button>
          <button type="button" class="secondary-link" id="cancelScan">Cancel</button>
        </div>
      </div>
    </div>
  </div>

    <script>
    const TEAM_COUNT = 11;
    const PUZZLE_COUNT = 12;
    const COOKIE_NAME = "towerHuntProgress";
    const CACHE_DURATION_DAYS = 365;

    const TEAM_NAMES = [
      "Team 1",
      "Team 2",
      "Team 3",
      "Team 4",
      "Team 5",
      "Team 6",
      "Team 7",
      "Team 8",
      "Team 9",
      "Team 10",
      "Team 11"
    ];

    const TEAM_ORDERS = [
      [1, 10, 3, 4, 7, 11, 8, 9, 5, 6, 2, 0],
      [2, 9, 4, 8, 11, 3, 6, 10, 5, 7, 1, 0],
      [3, 2, 4, 9, 5, 6, 1, 10, 7, 8, 11, 0],
      [4, 8, 9, 6, 5, 2, 1, 10, 7, 3, 11, 0],
      [5, 2, 10, 6, 3, 4, 11, 8, 1, 9, 7, 0],
      [6, 3, 11, 8, 9, 10, 1, 7, 2, 4, 5, 0],
      [7, 1, 3, 5, 11, 6, 2, 4, 8, 10, 9, 0],
      [8, 10, 3, 7, 11, 9, 4, 6, 2, 1, 5, 0],
      [9, 4, 11, 8, 6, 10, 3, 5, 2, 7, 1, 0],
      [10, 8, 11, 3, 5, 1, 6, 4, 7, 9, 2, 0],
      [11, 9, 4, 6, 5, 3, 8, 10, 1, 7, 2, 0]
    ];

    const QR_CODES = Object.freeze({
      BASEMENT: "BASEMENT-QR-000",
      FLOOR_1: "FLOOR1-QR-101",
      FLOOR_2: "FLOOR2-QR-202",
      FLOOR_3: "FLOOR3-QR-303",
      FLOOR_4: "FLOOR4-QR-404",
      FLOOR_5: "FLOOR5-QR-505",
      FLOOR_6: "FLOOR6-QR-606",
      FLOOR_7: "FLOOR7-QR-707",
      FLOOR_8: "FLOOR8-QR-808",
      FLOOR_9: "FLOOR9-QR-909",
      FLOOR_10: "FLOOR10-QR-010",
      FLOOR_11: "FLOOR11-QR-111"
    });

    const puzzles = [
      { floor: "Basement", prompt: "The answer is: 'tower'", qr: QR_CODES.BASEMENT },
      { floor: "Floor 1", prompt: "The answer is: 'tower'", qr: QR_CODES.FLOOR_1 },
      { floor: "Floor 2", prompt: "The answer is: 'tower'", qr: QR_CODES.FLOOR_2 },
      { floor: "Floor 3", prompt: "The answer is: 'tower'", qr: QR_CODES.FLOOR_3 },
      { floor: "Floor 4", prompt: "The answer is: 'tower'", qr: QR_CODES.FLOOR_4 },
      { floor: "Floor 5", prompt: "The answer is: 'tower'", qr: QR_CODES.FLOOR_5 },
      { floor: "Floor 6", prompt: "The answer is: 'tower'", qr: QR_CODES.FLOOR_6 },
      { floor: "Floor 7", prompt: "The answer is: 'tower'", qr: QR_CODES.FLOOR_7 },
      { floor: "Floor 8", prompt: "The answer is: 'tower'", qr: QR_CODES.FLOOR_8 },
      { floor: "Floor 9", prompt: "The answer is: 'tower'", qr: QR_CODES.FLOOR_9 },
      { floor: "Floor 10", prompt: "The answer is: 'tower'", qr: QR_CODES.FLOOR_10 },
      { floor: "Floor 11", prompt: "The answer is: 'tower'", qr: QR_CODES.FLOOR_11 }
    ];

    const progressBar = document.getElementById("progressBar");
    const progressCount = document.getElementById("progressCount");
    const progressLabel = document.getElementById("progressLabel");
    const resetButton = document.getElementById("resetAll");
    const exportButton = document.getElementById("exportProgress");
    const importButton = document.getElementById("importProgress");
    const statusMessage = document.getElementById("statusMessage");

    const puzzleTitle = document.getElementById("puzzleTitle");
    const puzzleMeta = document.getElementById("puzzleMeta");
    const puzzleBody = document.getElementById("puzzleBody");
    const puzzleFeedback = document.getElementById("puzzleFeedback");
    const scanButton = document.getElementById("scanButton");
    const reviewProgressButton = document.getElementById("reviewProgress");
    const platformTag = document.getElementById("platformTag");
    const progressList = document.getElementById("progressList");
    const progressPanel = document.getElementById("progressPanel");

    const teamModal = document.getElementById("teamModal");
    const teamGrid = document.getElementById("teamGrid");
    const scannerModal = document.getElementById("scannerModal");
    const scannerVideo = document.getElementById("scannerVideo");
    const scanStatus = document.getElementById("scanStatus");
    const manualCodeInput = document.getElementById("manualCode");
    const submitCodeButton = document.getElementById("submitCode");
    const cancelScanButton = document.getElementById("cancelScan");

    const defaultState = (teamId = null) => ({
      teamId,
      completions: Array.from({ length: PUZZLE_COUNT }, () => false)
    });

    let state = loadState();
    let statusTimeoutId = null;
    let scanSession = {
      stream: null,
      detector: null,
      rafId: null,
      activePuzzle: null
    };

    const hasMediaDevices = Boolean(navigator.mediaDevices?.getUserMedia);

    initialize();

    function initialize() {
      populateTeamGrid();
      detectPlatform();
      attachEventListeners();
      render();
    }

    function populateTeamGrid() {
      teamGrid.innerHTML = "";
      TEAM_NAMES.forEach((name, index) => {
        const button = document.createElement("button");
        button.type = "button";
        button.className = "team-select";
        button.textContent = name;
        button.dataset.team = index;
        button.addEventListener("click", () => handleTeamSelect(index));
        teamGrid.append(button);
      });
    }

    function handleTeamSelect(teamId) {
      const sanitizedTeam = clampNumber(teamId, 0, TEAM_COUNT - 1);
      const switchingTeams = state.teamId !== null && state.teamId !== sanitizedTeam && state.completions.some(Boolean);

      if (switchingTeams && !confirm("Switch teams and reset progress on this device?")) {
        return;
      }

      state = defaultState(sanitizedTeam);
      saveState();
      closeTeamModal();
      showStatus(`${TEAM_NAMES[sanitizedTeam]} mission queue ready.`, "success");
      render();
    }

    function openTeamModal() {
      teamModal.hidden = false;
    }

    function closeTeamModal() {
      teamModal.hidden = true;
    }

    function detectPlatform() {
      const ua = navigator.userAgent || "";
      const isIOS = /iPad|iPhone|iPod/.test(ua);
      const isAndroid = /Android/.test(ua);
      const isMobile = /Mobi|Android/i.test(ua);
      let label = isMobile ? "Platform: Mobile" : "Platform: Desktop";
      if (isIOS) label += " • iOS";
      if (isAndroid) label += " • Android";
      if (!hasMediaDevices) {
        label += " • Camera unavailable";
      }
      platformTag.textContent = label;
    }

    function attachEventListeners() {
      resetButton?.addEventListener("click", () => {
        if (!confirm("Reset all progress on this device?")) return;
        state = defaultState(state.teamId);
        saveState();
        render();
        showStatus("Progress reset.", "success");
      });

      exportButton?.addEventListener("click", exportProgress);
      importButton?.addEventListener("click", importProgress);

      scanButton?.addEventListener("click", () => {
        const activePuzzle = getActivePuzzleIndex();
        if (activePuzzle === null) {
          showStatus("All missions already cleared.");
          return;
        }
        openScanner(activePuzzle);
      });

      reviewProgressButton?.addEventListener("click", () => {
        progressPanel.scrollIntoView({ behavior: "smooth", block: "center" });
        showStatus("Mission queue updated.");
      });

      submitCodeButton?.addEventListener("click", () => {
        const code = manualCodeInput.value.trim();
        if (!code) {
          updateScanStatus("Enter a code before submitting.", "error");
          manualCodeInput.focus();
          return;
        }
        handleScanResult(code);
      });

      cancelScanButton?.addEventListener("click", () => {
        closeScanner("Scan cancelled.");
      });

      window.addEventListener("beforeunload", stopScannerStream);
      document.addEventListener("visibilitychange", () => {
        if (document.hidden) {
          stopScannerStream();
        }
      });
    }

    function loadState() {
      const cookieValue = getCookie(COOKIE_NAME);
      if (!cookieValue) {
        return defaultState(null);
      }
      try {
        const decoded = decodeCookieValue(cookieValue);
        const parsed = JSON.parse(decoded);
        return sanitizeState(parsed);
      } catch (err) {
        console.warn("Failed to parse cookie, resetting progress", err);
        return defaultState(null);
      }
    }

    function saveState() {
      state = sanitizeState(state);
      const payload = JSON.stringify(state);
      const maxAge = CACHE_DURATION_DAYS * 24 * 60 * 60;
      document.cookie = `${COOKIE_NAME}=${encodeURIComponent(payload)}; max-age=${maxAge}; path=/; SameSite=Lax`;
    }

    function getCookie(name) {
      const prefix = `${name}=`;
      return document.cookie
        .split(";")
        .map(entry => entry.trim())
        .find(entry => entry.startsWith(prefix))
        ?.slice(prefix.length)
        ?.replace(/^"|"$/g, "");
    }

    function decodeCookieValue(value) {
      try {
        return decodeURIComponent(value);
      } catch (err) {
        return value;
      }
    }

    function sanitizeState(candidate) {
      const fallback = defaultState(null);
      if (!candidate || typeof candidate !== "object") {
        return fallback;
      }

      let teamId = candidate.teamId;
      if (!Number.isInteger(teamId)) {
        teamId = clampNumber(candidate.activeTeam ?? 0, 0, TEAM_COUNT - 1);
      }
      teamId = clampNumber(teamId, 0, TEAM_COUNT - 1);

      let completions = candidate.completions;

      if (Array.isArray(candidate.progress) && candidate.progress.every(Array.isArray)) {
        const source = candidate.progress[clampNumber(candidate.activeTeam ?? teamId, 0, candidate.progress.length - 1)] ?? [];
        completions = source.map(Boolean);
      } else if (Array.isArray(candidate.progress)) {
        completions = candidate.progress.map(Boolean);
      }

      if (!Array.isArray(completions)) {
        completions = [];
      }

      const sanitizedCompletions = Array.from({ length: PUZZLE_COUNT }, (_, index) => Boolean(completions[index]));

      return {
        teamId,
        completions: sanitizedCompletions
      };
    }

    function clampNumber(value, min, max) {
      const n = Number.isFinite(value) ? Number(value) : min;
      return Math.min(Math.max(n, min), max);
    }

    function getTeamOrder() {
      if (!Number.isInteger(state.teamId)) {
        return [];
      }
      return TEAM_ORDERS[state.teamId]?.slice() ?? TEAM_ORDERS[0].slice();
    }

    function solvedCount() {
      return state.completions.filter(Boolean).length;
    }

    function getActivePuzzleIndex() {
      if (!Number.isInteger(state.teamId)) {
        return null;
      }
      const order = getTeamOrder();
      const next = order.find(index => !state.completions[index]);
      return typeof next === "number" ? next : null;
    }

    function render() {
      if (!Number.isInteger(state.teamId)) {
        openTeamModal();
        disableStage();
      } else {
        closeTeamModal();
        enableStage();
      }

      renderProgress();
      renderProgressList();
      renderPuzzle();
    }

    function disableStage() {
      scanButton.disabled = true;
      reviewProgressButton.disabled = true;
      puzzleTitle.textContent = "Select a Team";
      puzzleMeta.textContent = "Awaiting mission queue";
      puzzleBody.textContent = "Choose your team to load the tower mission order.";
      puzzleFeedback.textContent = "";
    }

    function enableStage() {
      scanButton.disabled = false;
      reviewProgressButton.disabled = false;
    }

    function renderProgress() {
      const solved = solvedCount();
      progressBar.max = PUZZLE_COUNT;
      progressBar.value = solved;
      progressCount.textContent = `${solved} / ${PUZZLE_COUNT} floors cleared`;
      const teamName = Number.isInteger(state.teamId) ? TEAM_NAMES[state.teamId] : "";
      progressLabel.textContent = teamName ? `${teamName} Progress` : "Hunt Progress";
    }

    function renderProgressList() {
      const order = getTeamOrder();
      if (!order.length) {
        progressList.innerHTML = "<p>No team selected.</p>";
        return;
      }

      const active = getActivePuzzleIndex();

      progressList.innerHTML = "";
      order.forEach((puzzleIndex, sequenceIndex) => {
        const item = document.createElement("div");
        item.className = "progress-item";

        if (state.completions[puzzleIndex]) {
          item.classList.add("complete");
        } else if (puzzleIndex === active) {
          item.classList.add("active");
        }

        const indexBadge = document.createElement("div");
        indexBadge.className = "progress-index";
        indexBadge.textContent = sequenceIndex + 1;

        const content = document.createElement("div");
        content.className = "progress-content";
        const title = document.createElement("div");
        title.textContent = puzzles[puzzleIndex].floor;

        const status = document.createElement("div");
        status.className = "progress-status";
        if (state.completions[puzzleIndex]) {
          status.classList.add("unlocked");
          status.textContent = "Cleared";
        } else if (puzzleIndex === active) {
          status.classList.add("unlocked");
          status.textContent = "Ready";
        } else {
          status.classList.add("locked");
          status.textContent = "Locked";
        }

        content.append(title, status);
        item.append(indexBadge, content);
        progressList.append(item);
      });
    }

    function renderPuzzle() {
      const activePuzzle = getActivePuzzleIndex();

      if (activePuzzle === null) {
        puzzleTitle.textContent = "Tower Run Complete";
        puzzleMeta.textContent = Number.isInteger(state.teamId)
          ? `${TEAM_NAMES[state.teamId]} • Mission complete`
          : "Mission complete";
        puzzleBody.textContent = "Every level from the basement through Floor 11 is secure. Await further instructions or reset to replay.";
        puzzleFeedback.textContent = "";
        scanButton.disabled = true;
        return;
      }

      const order = getTeamOrder();
      const stepNumber = order.indexOf(activePuzzle) + 1;
      const puzzle = puzzles[activePuzzle];

      puzzleTitle.textContent = puzzle.floor;
      puzzleMeta.textContent = `${TEAM_NAMES[state.teamId]} • Step ${stepNumber} of ${PUZZLE_COUNT}`;
      puzzleBody.textContent = puzzle.prompt;
      puzzleFeedback.textContent = "Scan the QR code for this level to unlock the next mission.";
      scanButton.disabled = false;
    }

    function openScanner(puzzleIndex) {
      scanSession.activePuzzle = puzzleIndex;
      scannerModal.hidden = false;
      manualCodeInput.value = "";
      updateScanStatus("Initializing camera…");
      startScannerStream();
    }

    async function startScannerStream() {
      stopScannerStream();

      if (!hasMediaDevices) {
        updateScanStatus("Camera unavailable. Enter the code manually.", "error");
        return;
      }

      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
        scanSession.stream = stream;
        scannerVideo.srcObject = stream;
        await scannerVideo.play();

        if (window.BarcodeDetector) {
          scanSession.detector = new window.BarcodeDetector({ formats: ["qr_code"] });
          scanSession.rafId = requestAnimationFrame(scanLoop);
          updateScanStatus("Scanning… Align the QR inside the frame.");
        } else {
          updateScanStatus("QR detector unavailable. Enter the code manually.", "error");
        }
      } catch (err) {
        console.error("Unable to start camera", err);
        updateScanStatus("Camera access denied. Enter the code manually.", "error");
      }
    }

    async function scanLoop() {
      if (!scanSession.detector || scannerVideo.readyState !== 4) {
        scanSession.rafId = requestAnimationFrame(scanLoop);
        return;
      }

      try {
        const barcodes = await scanSession.detector.detect(scannerVideo);
        if (barcodes.length > 0) {
          const value = barcodes[0].rawValue;
          handleScanResult(value);
          return;
        }
      } catch (err) {
        console.error("Barcode detection failed", err);
      }

      scanSession.rafId = requestAnimationFrame(scanLoop);
    }

    function handleScanResult(value) {
      if (scanSession.activePuzzle === null) {
        return;
      }

      const expected = puzzles[scanSession.activePuzzle].qr;
      const normalizedValue = normalizeCode(value);
      const normalizedExpected = normalizeCode(expected);

      if (normalizedValue === normalizedExpected) {
        completePuzzle(scanSession.activePuzzle, value);
      } else {
        updateScanStatus("Code mismatch. Ensure you scanned the correct floor QR.", "error");
      }
    }

    function completePuzzle(puzzleIndex, rawValue) {
      state.completions[puzzleIndex] = true;
      saveState();
      closeScanner(`Code accepted (${rawValue}).`);
      showStatus(`${puzzles[puzzleIndex].floor} unlocked.`, "success");
      render();
    }

    function closeScanner(message) {
      if (message) {
        updateScanStatus(message, message.includes("accepted") ? "success" : undefined);
      }
      stopScannerStream();
      scannerModal.hidden = true;
      scanSession.activePuzzle = null;
    }

    function stopScannerStream() {
      if (scanSession.rafId) {
        cancelAnimationFrame(scanSession.rafId);
        scanSession.rafId = null;
      }
      if (scanSession.stream) {
        scanSession.stream.getTracks().forEach(track => track.stop());
        scanSession.stream = null;
      }
      if (scannerVideo.srcObject) {
        scannerVideo.srcObject = null;
      }
      scanSession.detector = null;
    }

    function updateScanStatus(message, tone) {
      scanStatus.textContent = message;
      scanStatus.className = "scan-status";
      if (tone === "success") {
        scanStatus.classList.add("success");
      } else if (tone === "error") {
        scanStatus.classList.add("error");
      }
    }

    function normalizeCode(value) {
      return value.trim().toUpperCase().replace(/[^A-Z0-9-]/g, "");
    }

    function showStatus(message, tone = "info") {
      if (!statusMessage) return;
      statusMessage.className = "status-message";
      if (tone === "success") {
        statusMessage.classList.add("success");
      } else if (tone === "error") {
        statusMessage.classList.add("error");
      }
      statusMessage.textContent = message;
      statusMessage.classList.add("visible");

      if (statusTimeoutId) {
        clearTimeout(statusTimeoutId);
      }
      statusTimeoutId = window.setTimeout(() => {
        statusMessage.className = "status-message";
        statusMessage.textContent = "";
        statusTimeoutId = null;
      }, 4500);
    }

    function fallbackCopyPrompt(code) {
      const promptMessage = "Progress code ready. Press Ctrl+C (Cmd+C on Mac) to copy:";
      const response = window.prompt(promptMessage, code);
      if (response !== null) {
        showStatus("Progress code ready to share.", "success");
      } else {
        showStatus("Copy cancelled.");
      }
    }

    function createShareCode(currentState) {
      const sanitized = sanitizeState(currentState);
      return btoa(JSON.stringify(sanitized));
    }

    function exportProgress() {
      const shareCode = createShareCode(state);
      if (navigator.clipboard?.writeText) {
        navigator.clipboard
          .writeText(shareCode)
          .then(() => showStatus("Copied progress code to clipboard.", "success"))
          .catch(() => {
            fallbackCopyPrompt(shareCode);
          });
        return;
      }

      fallbackCopyPrompt(shareCode);
    }

    function parseProgressInput(rawInput) {
      const trimmed = rawInput.trim();
      if (!trimmed) {
        throw new Error("No data supplied");
      }

      const cookiePattern = new RegExp(`${COOKIE_NAME}=([^;\s]+)`);
      const cookieMatch = trimmed.match(cookiePattern);
      const encoded = cookieMatch ? cookieMatch[1] : trimmed;

      const candidates = new Set([encoded]);
      const decoded = decodeCookieValue(encoded);
      candidates.add(decoded);

      try {
        candidates.add(atob(encoded));
      } catch (err) {
        // ignore
      }

      try {
        candidates.add(atob(decoded));
      } catch (err) {
        // ignore
      }

      for (const candidate of candidates) {
        if (!candidate || typeof candidate !== "string") continue;
        try {
          return JSON.parse(candidate);
        } catch (err) {
          // continue
        }
      }

      throw new Error("Unable to parse progress input");
    }

    function importProgress() {
      const input = window.prompt("Paste a progress code or cookie value to import:");
      if (input === null) {
        showStatus("Import cancelled.");
        return;
      }

      if (!input.trim()) {
        showStatus("Nothing to import. Paste a code and try again.", "error");
        return;
      }

      try {
        const parsed = parseProgressInput(input);
        state = sanitizeState(parsed);
        saveState();
        render();
        showStatus("Progress imported successfully.", "success");
      } catch (err) {
        console.error("Import failed", err);
        showStatus("Import failed. Check the code and try again.", "error");
      }
    }
  </script>
</body>
</html>
