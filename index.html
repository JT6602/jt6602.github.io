<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tower Scavenger Hunt Control Room</title>
  <style>
    :root {
      color-scheme: light dark;
      --bg: #0b132b;
      --panel: rgba(17, 34, 64, 0.92);
      --accent: #5bc0be;
      --accent-soft: rgba(91, 192, 190, 0.1);
      --text: #e0f1ff;
      --text-muted: rgba(224, 241, 255, 0.72);
      --danger: #f67280;
      font-family: "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    .is-hidden {
      display: none !important;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at top, rgba(91, 192, 190, 0.2), transparent 55%),
        linear-gradient(180deg, rgba(11, 19, 43, 0.96) 0%, rgba(5, 8, 19, 0.98) 100%);
      color: var(--text);
      display: flex;
      justify-content: center;
      padding: 2rem 1.5rem 3rem;
    }

    main {
      width: min(1200px, 100%);
      background: rgba(3, 9, 21, 0.78);
      border: 1px solid rgba(91, 192, 190, 0.25);
      border-radius: 24px;
      backdrop-filter: blur(14px);
      box-shadow: 0 30px 70px -35px black;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-height: calc(100vh - 6rem);
    }

    header {
      padding: 2.5rem clamp(1.5rem, 4vw, 3rem) 2rem;
      background: linear-gradient(135deg, rgba(91, 192, 190, 0.22), rgba(72, 149, 239, 0.08));
      border-bottom: 1px solid rgba(91, 192, 190, 0.18);
    }

    h1 {
      margin: 0;
      font-size: clamp(2rem, 4vw, 2.8rem);
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    header p {
      margin: 0.75rem 0 0;
      max-width: 620px;
      color: var(--text-muted);
      line-height: 1.6;
      font-size: 0.98rem;
    }

    .control-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      padding: 1.5rem clamp(1.5rem, 4vw, 3rem) 1rem;
      align-items: center;
      background: rgba(7, 16, 33, 0.85);
      border-bottom: 1px solid rgba(91, 192, 190, 0.18);
    }

    .progress-panel {
      display: flex;
      gap: 1rem;
      align-items: center;
      flex-wrap: wrap;
    }

    .action-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
    }

    .action-button {
      background: rgba(91, 192, 190, 0.14);
      color: var(--text);
      border: 1px solid rgba(91, 192, 190, 0.4);
      border-radius: 10px;
      padding: 0.55rem 0.95rem;
      font-size: 0.9rem;
      letter-spacing: 0.04em;
      cursor: pointer;
      transition: all 0.18s ease;
    }

    .action-button:hover,
    .action-button:focus-visible {
      outline: none;
      border-color: var(--accent);
      background: rgba(91, 192, 190, 0.24);
      transform: translateY(-1px);
      box-shadow: 0 8px 18px -12px var(--accent);
    }

    .status-message {
      flex-basis: 100%;
      font-size: 0.85rem;
      letter-spacing: 0.04em;
      padding: 0.55rem 0.85rem;
      border-radius: 8px;
      border: 1px solid transparent;
      background: rgba(91, 192, 190, 0.08);
      color: var(--text-muted);
      opacity: 0;
      transform: translateY(-6px);
      transition: opacity 0.22s ease, transform 0.22s ease;
    }

    .status-message.visible {
      opacity: 1;
      transform: translateY(0);
    }

    .status-message.success {
      border-color: rgba(91, 192, 190, 0.55);
      background: rgba(91, 192, 190, 0.18);
      color: var(--text);
    }

    .status-message.error {
      border-color: rgba(246, 114, 128, 0.65);
      background: rgba(246, 114, 128, 0.16);
      color: var(--danger);
    }

    .progress-wrapper {
      width: clamp(200px, 30vw, 360px);
    }

    .progress-label {
      font-size: 0.85rem;
      color: var(--text-muted);
      margin-bottom: 0.25rem;
      display: flex;
      justify-content: space-between;
    }

    .progress-bar {
      appearance: none;
      width: 100%;
      height: 10px;
      border-radius: 6px;
      background: rgba(91, 192, 190, 0.12);
      overflow: hidden;
    }

    .progress-bar::-webkit-progress-bar {
      background: rgba(91, 192, 190, 0.12);
    }

    .progress-bar::-webkit-progress-value {
      background: linear-gradient(90deg, var(--accent) 0%, #68d8d6 100%);
      border-radius: 6px;
    }

    .progress-bar::-moz-progress-bar {
      background: linear-gradient(90deg, var(--accent) 0%, #68d8d6 100%);
      border-radius: 6px;
    }

    .reset-button {
      background: none;
      border: 1px solid rgba(246, 114, 128, 0.6);
      color: var(--danger);
      padding: 0.55rem 0.9rem;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.85rem;
      letter-spacing: 0.04em;
      transition: all 0.18s ease;
    }

    .reset-button:hover,
    .reset-button:focus-visible {
      outline: none;
      background: rgba(246, 114, 128, 0.12);
      border-color: rgba(246, 114, 128, 0.9);
    }

    .stage {
      flex: 1;
      display: grid;
      grid-template-columns: minmax(0, 2.1fr) minmax(220px, 1fr);
      gap: clamp(1.5rem, 4vw, 2.5rem);
      padding: clamp(1.5rem, 5vw, 3rem);
      background: rgba(4, 12, 24, 0.78);
    }

    .puzzle-view {
      border: 1px solid rgba(91, 192, 190, 0.25);
      background: rgba(8, 22, 46, 0.82);
      border-radius: 22px;
      padding: clamp(1.5rem, 4vw, 3rem);
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      min-height: 480px;
      box-shadow: inset 0 0 35px -28px rgba(91, 192, 190, 0.6);
      position: relative;
      overflow: hidden;
    }

    .puzzle-hero {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      position: relative;
      z-index: 1;
    }

    .puzzle-hero h2 {
      margin: 0;
      font-size: clamp(2rem, 4vw, 2.8rem);
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .puzzle-meta-line {
      display: flex;
      flex-wrap: wrap;
      gap: 0.65rem;
      font-size: 0.95rem;
      color: var(--text-muted);
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }

    .puzzle-body {
      flex: 1;
      font-size: clamp(1rem, 2.6vw, 1.15rem);
      line-height: 1.7;
      color: var(--text-muted);
      max-width: 70ch;
      position: relative;
      z-index: 1;
    }

    .stage-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: center;
      position: relative;
      z-index: 1;
    }

    .waiting-aurora {
      position: absolute;
      inset: -25% -15% 0;
      pointer-events: none;
      opacity: 0;
      filter: saturate(1.5);
      transition: opacity 0.45s ease;
      z-index: 0;
    }

    .waiting-aurora.is-active {
      opacity: 0.9;
    }

    .waiting-aurora span {
      position: absolute;
      display: block;
      border-radius: 999px;
      mix-blend-mode: screen;
      filter: blur(18px);
      opacity: 0.75;
      animation: auroraDrift 14s ease-in-out infinite;
    }

    .waiting-aurora span:nth-child(1) {
      width: 48%;
      height: 48%;
      top: 12%;
      left: -6%;
      background: radial-gradient(circle at 30% 30%, rgba(91, 192, 190, 0.45), rgba(15, 120, 180, 0.08) 70%);
    }

    .waiting-aurora span:nth-child(2) {
      width: 56%;
      height: 56%;
      top: 28%;
      right: -12%;
      background: radial-gradient(circle at 70% 30%, rgba(120, 91, 248, 0.5), rgba(9, 24, 60, 0.05) 80%);
      animation-duration: 17s;
      animation-delay: -4s;
    }

    .waiting-aurora span:nth-child(3) {
      width: 42%;
      height: 42%;
      bottom: -8%;
      left: 28%;
      background: radial-gradient(circle at 50% 50%, rgba(255, 209, 102, 0.35), rgba(18, 34, 72, 0.02) 85%);
      animation-duration: 21s;
      animation-delay: -9s;
    }

    @keyframes auroraDrift {
      0% {
        transform: translate3d(0, 0, 0) scale(1);
      }
      25% {
        transform: translate3d(6%, -4%, 0) scale(1.05) rotate(2deg);
      }
      50% {
        transform: translate3d(-4%, 8%, 0) scale(1.08) rotate(-3deg);
      }
      75% {
        transform: translate3d(3%, 4%, 0) scale(1.02) rotate(1deg);
      }
      100% {
        transform: translate3d(0, 0, 0) scale(1);
      }
    }

    .answer-form {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
      position: relative;
      z-index: 1;
    }

    .answer-form input {
      flex: 1;
      min-width: 220px;
      border-radius: 12px;
      border: 1px solid rgba(91, 192, 190, 0.3);
      background: rgba(3, 15, 32, 0.72);
      color: var(--text);
      padding: 0.65rem 0.85rem;
      letter-spacing: 0.05em;
      font-size: 0.95rem;
    }

    .answer-form button {
      flex-shrink: 0;
    }

    .answer-feedback {
      font-size: 0.85rem;
      letter-spacing: 0.05em;
      color: var(--text-muted);
      min-height: 1.2rem;
      position: relative;
      z-index: 1;
    }

    .answer-feedback.success {
      color: var(--accent);
    }

    .answer-feedback.error {
      color: var(--danger);
    }

    .primary-action {
      border: none;
      border-radius: 12px;
      padding: 0.85rem 1.6rem;
      font-size: 1rem;
      letter-spacing: 0.08em;
      font-weight: 600;
      cursor: pointer;
      background: linear-gradient(135deg, var(--accent), #6ff0eb);
      color: #041128;
      box-shadow: 0 15px 32px -20px var(--accent);
      transition: transform 0.18s ease, box-shadow 0.18s ease, filter 0.18s ease;
    }

    .primary-action:hover,
    .primary-action:focus-visible {
      outline: none;
      transform: translateY(-2px);
      box-shadow: 0 18px 36px -18px var(--accent);
      filter: brightness(1.05);
    }

    .secondary-link {
      background: none;
      border: 1px solid rgba(91, 192, 190, 0.4);
      color: var(--accent);
      border-radius: 999px;
      padding: 0.5rem 1.1rem;
      font-size: 0.9rem;
      letter-spacing: 0.05em;
      cursor: pointer;
      transition: border-color 0.18s ease, background 0.18s ease;
    }

    .secondary-link:hover,
    .secondary-link:focus-visible {
      outline: none;
      border-color: var(--accent);
      background: rgba(91, 192, 190, 0.18);
    }

    .progress-track {
      border: 1px solid rgba(91, 192, 190, 0.2);
      background: rgba(5, 16, 35, 0.82);
      border-radius: 20px;
      padding: clamp(1.2rem, 3vw, 2rem);
      display: flex;
      flex-direction: column;
      gap: 1.2rem;
      position: relative;
    }

    .tower-map {
      border: 1px solid rgba(91, 192, 190, 0.22);
      border-radius: 16px;
      padding: 1.1rem 1rem 1.25rem;
      background: linear-gradient(180deg, rgba(12, 26, 46, 0.78), rgba(5, 12, 26, 0.9));
      box-shadow: inset 0 0 28px -24px rgba(91, 192, 190, 0.55);
      display: flex;
      flex-direction: column;
      gap: 0.85rem;
      margin-top: 0.6rem;
    }

    .tower-map-title {
      font-size: 0.88rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: rgba(224, 241, 255, 0.72);
    }

    .tower-map-levels {
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
      position: relative;
    }

    .tower-map-level {
      display: flex;
      justify-content: space-between;
      align-items: center;
      border: 1px solid rgba(91, 192, 190, 0.25);
      border-radius: 12px;
      padding: 0.55rem 0.75rem;
      background: rgba(11, 24, 46, 0.75);
      transition: transform 0.2s ease, border-color 0.2s ease, background 0.2s ease;
      min-height: 46px;
    }

    .tower-map-level.is-pending {
      border-color: rgba(91, 192, 190, 0.12);
      background: rgba(8, 18, 36, 0.65);
    }

    .tower-map-level.is-locked {
      border-color: rgba(91, 192, 190, 0.16);
      background: rgba(8, 20, 40, 0.58);
    }

    .tower-map-level.is-revealed {
      border-color: rgba(91, 192, 190, 0.4);
      background: linear-gradient(135deg, rgba(91, 192, 190, 0.22), rgba(72, 149, 239, 0.18));
    }

    .tower-map-level.is-unlocked,
    .tower-map-level.is-active {
      border-color: rgba(91, 192, 190, 0.55);
      background: linear-gradient(135deg, rgba(91, 192, 190, 0.32), rgba(48, 189, 208, 0.28));
      transform: translateX(4px);
      box-shadow: 0 16px 30px -28px var(--accent);
    }

    .tower-map-level.is-solved {
      border-color: rgba(91, 192, 190, 0.75);
      background: linear-gradient(135deg, rgba(91, 192, 190, 0.42), rgba(64, 208, 197, 0.32));
    }

    .tower-map-label {
      font-size: 0.9rem;
      letter-spacing: 0.05em;
    }

    .tower-map-status {
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(224, 241, 255, 0.7);
    }

    .tower-map-level.is-solved .tower-map-status {
      color: #041128;
      font-weight: 600;
    }

    .tower-map-level.is-solved .tower-map-status,
    .tower-map-level.is-unlocked .tower-map-status,
    .tower-map-level.is-active .tower-map-status {
      color: #041128;
    }

    .tower-ground-line {
      height: 3px;
      width: 100%;
      border-radius: 999px;
      background: linear-gradient(90deg, rgba(91, 192, 190, 0.15), var(--accent), rgba(91, 192, 190, 0.15));
      box-shadow: 0 0 10px rgba(91, 192, 190, 0.35);
      position: relative;
      margin: 0.2rem 0 0.4rem;
    }

    @media (max-width: 720px) {
      .tower-map {
        padding: 1rem 0.85rem 1.1rem;
        gap: 0.7rem;
      }
      .tower-map-level {
        min-height: 42px;
        padding: 0.5rem 0.65rem;
      }
      .tower-map-level.is-unlocked,
      .tower-map-level.is-active {
        transform: none;
        box-shadow: 0 10px 24px -28px var(--accent);
      }
      .waiting-aurora {
        inset: -32% -20% -4%;
        opacity: 0.75;
      }
      .waiting-aurora span {
        filter: blur(22px);
      }
    }

    @media (prefers-reduced-motion: reduce) {
      *,
      *::before,
      *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
        scroll-behavior: auto !important;
      }
      .waiting-aurora {
        display: none !important;
      }
    }

    .progress-track h3 {
      margin: 0;
      font-size: 1.05rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--text-muted);
    }

    .progress-list {
      display: flex;
      flex-direction: column;
      gap: 0.85rem;
      overflow: auto;
      max-height: min(60vh, 520px);
      padding-right: 0.3rem;
    }

    .progress-item {
      border: 1px solid rgba(91, 192, 190, 0.2);
      border-radius: 14px;
      padding: 0.8rem 1rem;
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 0.75rem;
      align-items: center;
      background: rgba(8, 24, 48, 0.7);
      font-size: 0.92rem;
      letter-spacing: 0.04em;
      transition: border-color 0.18s ease, transform 0.18s ease;
    }

    .progress-content {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .progress-item.active {
      border-color: rgba(91, 192, 190, 0.6);
      background: rgba(18, 44, 72, 0.85);
      box-shadow: 0 20px 40px -28px var(--accent);
      transform: translateX(6px);
    }

    .progress-item.complete {
      border-color: rgba(91, 192, 190, 0.8);
      background: rgba(28, 53, 74, 0.85);
    }

    .progress-index {
      width: 34px;
      height: 34px;
      border-radius: 50%;
      display: grid;
      place-items: center;
      font-weight: 600;
      background: rgba(91, 192, 190, 0.18);
      color: var(--accent);
    }

    .progress-item.complete .progress-index {
      background: var(--accent);
      color: #041128;
    }

    .progress-status {
      font-size: 0.78rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(224, 241, 255, 0.6);
    }

    .progress-status.unlocked {
      color: var(--accent);
    }

    .progress-status.locked {
      color: rgba(224, 241, 255, 0.35);
    }

    .platform-tag {
      font-size: 0.82rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(224, 241, 255, 0.6);
      display: inline-flex;
      gap: 0.4rem;
      align-items: center;
    }

    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(4, 10, 22, 0.8);
      backdrop-filter: blur(10px);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1.5rem;
      z-index: 1000;
    }

    .modal-backdrop[hidden] {
      display: none;
    }

    .modal-dialog {
      background: rgba(6, 18, 40, 0.9);
      border: 1px solid rgba(91, 192, 190, 0.35);
      border-radius: 20px;
      padding: clamp(1.5rem, 4vw, 2.5rem);
      width: min(480px, 100%);
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      color: var(--text);
      box-shadow: 0 30px 80px -45px black;
    }

    .modal-dialog h2 {
      margin: 0;
      font-size: clamp(1.4rem, 4vw, 2rem);
      letter-spacing: 0.1em;
      text-transform: uppercase;
    }

    .modal-dialog p {
      margin: 0;
      color: var(--text-muted);
      line-height: 1.6;
      font-size: 0.95rem;
    }

    .team-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 0.9rem;
    }

    .team-select {
      border: 1px solid rgba(91, 192, 190, 0.4);
      border-radius: 14px;
      padding: 0.85rem 1rem;
      font-size: 1rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--text);
      background: rgba(12, 30, 54, 0.8);
      cursor: pointer;
      transition: transform 0.18s ease, border-color 0.18s ease, background 0.18s ease;
    }

    .team-select:hover,
    .team-select:focus-visible {
      outline: none;
      border-color: var(--accent);
      background: rgba(91, 192, 190, 0.2);
      transform: translateY(-2px);
    }

    .scanner-shell {
      display: grid;
      gap: 1rem;
    }

    .scanner-video {
      width: 100%;
      border-radius: 18px;
      border: 1px solid rgba(91, 192, 190, 0.3);
      background: rgba(3, 9, 21, 0.8);
    }

    .scan-status {
      font-size: 0.9rem;
      color: var(--text-muted);
      letter-spacing: 0.04em;
      min-height: 1.2rem;
    }

    .scan-status.success {
      color: var(--accent);
    }

    .scan-status.error {
      color: var(--danger);
    }

    .manual-entry {
      display: flex;
      gap: 0.75rem;
      align-items: stretch;
      flex-wrap: wrap;
    }

    .manual-entry input {
      flex: 1;
      min-width: 180px;
      border-radius: 12px;
      border: 1px solid rgba(91, 192, 190, 0.3);
      background: rgba(3, 15, 32, 0.72);
      color: var(--text);
      padding: 0.65rem 0.85rem;
      letter-spacing: 0.05em;
      font-size: 0.95rem;
    }

    .manual-entry input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(91, 192, 190, 0.18);
    }


    .footer-note {
      padding: 1rem clamp(1.5rem, 4vw, 3rem) 2.2rem;
      color: rgba(224, 241, 255, 0.55);
      font-size: 0.85rem;
      letter-spacing: 0.04em;
      background: rgba(3, 9, 21, 0.8);
      border-top: 1px solid rgba(91, 192, 190, 0.18);
    }

    @media (max-width: 780px) {
      main {
        border-radius: 0;
        min-height: 100vh;
      }

      .control-bar {
        padding: 1.25rem clamp(1rem, 6vw, 1.75rem);
        gap: 1.25rem;
      }

      .progress-panel {
        width: 100%;
        justify-content: flex-start;
      }

      .progress-wrapper {
        width: 100%;
      }

      .stage {
        display: flex;
        flex-direction: column;
        padding: clamp(1.1rem, 6vw, 1.8rem);
        gap: 1.25rem;
      }

      .puzzle-view {
        min-height: 380px;
        padding: clamp(1.1rem, 5vw, 1.8rem);
      }

      .progress-track {
        padding: clamp(1rem, 5vw, 1.6rem);
        max-height: none;
      }

      .progress-list {
        flex-direction: row;
        overflow-x: auto;
        overflow-y: visible;
        max-height: none;
        gap: 0.75rem;
      }

      .progress-item {
        min-width: 220px;
        grid-template-columns: 1fr;
        gap: 0.5rem;
      }
    }

    @media (max-width: 520px) {
      body {
        padding: 0;
      }

      main {
        border-radius: 0;
      }

      .puzzle-hero h2 {
        font-size: clamp(1.6rem, 8vw, 2rem);
      }

      .stage-actions {
        flex-direction: column;
        align-items: stretch;
      }

      .primary-action,
      .secondary-link {
        width: 100%;
        text-align: center;
      }
    }
  </style>
</head>
<body>
  <main>
    <header>
      <h1>The Tower Scavenger Hunt</h1>
      <p>
        Track your tower run across the basement and eleven upper floors of challenges. As puzzle content is finalized, replace
        the filler text inside
        each floor card. Progress is saved locally with cookies, so you can refresh or return to this page without losing your place.
      </p>
    </header>

    <section class="control-bar">
      <div class="progress-panel">
        <div class="progress-wrapper">
          <div class="progress-label">
            <span id="progressLabel">Hunt Progress</span>
            <span id="progressCount"></span>
          </div>
          <progress id="progressBar" class="progress-bar" value="0" max="11"></progress>
        </div>
      </div>
      <div class="action-buttons">
        <button type="button" class="action-button" id="exportProgress">Copy Progress Code</button>
        <button type="button" class="action-button" id="importProgress">Import Progress</button>
        <button type="button" class="reset-button" id="resetAll">Reset Progress</button>
      </div>
      <div class="status-message" id="statusMessage" role="status" aria-live="polite"></div>
    </section>

    <section class="stage" aria-live="polite">
      <article class="puzzle-view" id="puzzleView">
        <div class="waiting-aurora" id="waitingAurora" aria-hidden="true">
          <span></span>
          <span></span>
          <span></span>
        </div>
        <div class="puzzle-hero">
          <h2 id="puzzleTitle">Loading Mission</h2>
          <div class="puzzle-meta-line" id="puzzleMeta"></div>
        </div>
        <div class="puzzle-body" id="puzzleBody"></div>
        <div class="stage-actions">
          <button type="button" class="primary-action" id="scanButton" disabled>Start QR Scan</button>
          <button type="button" class="secondary-link" id="reviewProgress">View Mission Queue</button>
        </div>
        <form class="answer-form is-hidden" id="answerForm">
          <input
            type="text"
            id="answerInput"
            placeholder="Enter puzzle answer"
            aria-label="Puzzle answer"
            autocomplete="off"
            inputmode="text"
          />
          <button type="submit" class="primary-action" id="answerSubmit">Submit Answer</button>
        </form>
        <div class="answer-feedback" id="puzzleFeedback" aria-live="polite"></div>
      </article>
      <aside class="progress-track" id="progressPanel">
        <div class="platform-tag" id="platformTag">Platform: Detecting…</div>
        <h3>Mission Queue</h3>
        <div class="progress-list" id="progressList"></div>
        <div class="tower-map" id="towerMap" aria-label="Tower map">
          <div class="tower-map-title">Tower Map</div>
          <div class="tower-map-levels" id="towerLevels"></div>
        </div>
      </aside>
    </section>

    <footer class="footer-note">
      Tip: want to stage new puzzle text? Update the placeholders here and commit the file to GitHub Pages. Cookie storage lasts
      one year and is scoped to this page.
    </footer>
  </main>

  <div class="modal-backdrop" id="scannerModal" hidden>
    <div class="modal-dialog" role="dialog" aria-modal="true" aria-labelledby="scannerTitle">
      <div class="scanner-shell">
        <h2 id="scannerTitle">Scan Mission QR</h2>
        <p id="scannerInstruction">Align the QR code inside the frame. We’ll automatically validate the code for this floor.</p>
        <video class="scanner-video" id="scannerVideo" playsinline></video>
        <div class="scan-status" id="scanStatus"></div>
        <div class="manual-entry">
          <input type="text" id="manualCode" placeholder="Enter code manually" autocomplete="off" inputmode="search" />
          <button type="button" class="primary-action" id="submitCode">Submit Code</button>
          <button type="button" class="secondary-link" id="cancelScan">Cancel</button>
        </div>
      </div>
    </div>
  </div>

    <script>
    const TEAM_COUNT = 11;
    const PUZZLE_COUNT = 12;
    const COOKIE_NAME = "towerHuntProgress";
    const CACHE_DURATION_DAYS = 365;

    const TEAM_NAMES = [
      "Team 1",
      "Team 2",
      "Team 3",
      "Team 4",
      "Team 5",
      "Team 6",
      "Team 7",
      "Team 8",
      "Team 9",
      "Team 10",
      "Team 11"
    ];

    const TEAM_ORDERS = [
      [1, 10, 3, 4, 7, 11, 8, 9, 5, 6, 2, 0],
      [2, 9, 4, 8, 11, 3, 6, 10, 5, 7, 1, 0],
      [3, 2, 4, 9, 5, 6, 1, 10, 7, 8, 11, 0],
      [4, 8, 9, 6, 5, 2, 1, 10, 7, 3, 11, 0],
      [5, 2, 10, 6, 3, 4, 11, 8, 1, 9, 7, 0],
      [6, 3, 11, 8, 9, 10, 1, 7, 2, 4, 5, 0],
      [7, 1, 3, 5, 11, 6, 2, 4, 8, 10, 9, 0],
      [8, 10, 3, 7, 11, 9, 4, 6, 2, 1, 5, 0],
      [9, 4, 11, 8, 6, 10, 3, 5, 2, 7, 1, 0],
      [10, 8, 11, 3, 5, 1, 6, 4, 7, 9, 2, 0],
      [11, 9, 4, 6, 5, 3, 8, 10, 1, 7, 2, 0]
    ];

    const QR_CODES = Object.freeze({
      BASEMENT: "Z7PX-HL0Q-AV34",
      FLOOR_1: "M1QF-8RVZ-T6JD",
      FLOOR_2: "Q4SN-P2LX-9G0B",
      FLOOR_3: "V9KT-3H2C-LM55",
      FLOOR_4: "RX1B-W8Q7-5LZJ",
      FLOOR_5: "T0HC-4ZKM-PP18",
      FLOOR_6: "C8FW-J3VQ-7N2S",
      FLOOR_7: "L5MB-Y6RT-XQ04",
      FLOOR_8: "H2SV-N9PC-41LJ",
      FLOOR_9: "G7QD-K0LX-UF82",
      FLOOR_10: "P6ZR-2WQJ-M31T",
      FLOOR_11: "B3XN-5TLY-VA96"
    });

    const START_CODES = Object.freeze({
      "FRACTAL-DAWN-91QX": 0,
      "ORBITAL-GLASS-62MT": 1,
      "VELVET-EMBER-47NS": 2,
      "SONAR-MOON-18PL": 3,
      "EMBER-MASK-03VZ": 4,
      "CRYPTIC-FIELD-76QA": 5,
      "NEBULA-RIDGE-55LX": 6,
      "MIRAGE-COIL-24HF": 7,
      "SAPPHIRE-DUSK-88WR": 8,
      "PRISM-HARBOR-69KU": 9,
      "GOSSAMER-VAULT-12EC": 10
    });

    const GM_TEAM_CODES = Object.freeze({
      "GM-FRACTAL-REMAP-742": 0,
      "GM-ORBITAL-REMAP-953": 1,
      "GM-VELVET-REMAP-184": 2,
      "GM-SONAR-REMAP-625": 3,
      "GM-EMBER-REMAP-307": 4,
      "GM-CRYPTIC-REMAP-571": 5,
      "GM-NEBULA-REMAP-468": 6,
      "GM-MIRAGE-REMAP-259": 7,
      "GM-SAPPHIRE-REMAP-836": 8,
      "GM-PRISM-REMAP-914": 9,
      "GM-GOSSAMER-REMAP-401": 10
    });

    const puzzles = [
      { floor: "Basement", prompt: "The answer is: 'tower'", answer: "tower", qr: QR_CODES.BASEMENT },
      { floor: "Floor 1", prompt: "The answer is: 'tower'", answer: "tower", qr: QR_CODES.FLOOR_1 },
      { floor: "Floor 2", prompt: "The answer is: 'tower'", answer: "tower", qr: QR_CODES.FLOOR_2 },
      { floor: "Floor 3", prompt: "The answer is: 'tower'", answer: "tower", qr: QR_CODES.FLOOR_3 },
      { floor: "Floor 4", prompt: "The answer is: 'tower'", answer: "tower", qr: QR_CODES.FLOOR_4 },
      { floor: "Floor 5", prompt: "The answer is: 'tower'", answer: "tower", qr: QR_CODES.FLOOR_5 },
      { floor: "Floor 6", prompt: "The answer is: 'tower'", answer: "tower", qr: QR_CODES.FLOOR_6 },
      { floor: "Floor 7", prompt: "The answer is: 'tower'", answer: "tower", qr: QR_CODES.FLOOR_7 },
      { floor: "Floor 8", prompt: "The answer is: 'tower'", answer: "tower", qr: QR_CODES.FLOOR_8 },
      { floor: "Floor 9", prompt: "The answer is: 'tower'", answer: "tower", qr: QR_CODES.FLOOR_9 },
      { floor: "Floor 10", prompt: "The answer is: 'tower'", answer: "tower", qr: QR_CODES.FLOOR_10 },
      { floor: "Floor 11", prompt: "The answer is: 'tower'", answer: "tower", qr: QR_CODES.FLOOR_11 }
    ];

    const PUZZLE_CODE_LOOKUP = Object.freeze(
      puzzles.reduce((map, puzzle, index) => {
        map[normalizeCode(puzzle.qr)] = index;
        return map;
      }, {})
    );

    const progressBar = document.getElementById("progressBar");
    const progressCount = document.getElementById("progressCount");
    const progressLabel = document.getElementById("progressLabel");
    const resetButton = document.getElementById("resetAll");
    const exportButton = document.getElementById("exportProgress");
    const importButton = document.getElementById("importProgress");
    const statusMessage = document.getElementById("statusMessage");

    const puzzleTitle = document.getElementById("puzzleTitle");
    const puzzleMeta = document.getElementById("puzzleMeta");
    const puzzleBody = document.getElementById("puzzleBody");
    const puzzleFeedback = document.getElementById("puzzleFeedback");
    const scanButton = document.getElementById("scanButton");
    const reviewProgressButton = document.getElementById("reviewProgress");
    const answerForm = document.getElementById("answerForm");
    const answerInput = document.getElementById("answerInput");
    const answerSubmitButton = document.getElementById("answerSubmit");
    const waitingAurora = document.getElementById("waitingAurora");
    const platformTag = document.getElementById("platformTag");
    const progressList = document.getElementById("progressList");
    const progressPanel = document.getElementById("progressPanel");
    const towerLevels = document.getElementById("towerLevels");

    const scannerModal = document.getElementById("scannerModal");
    const scannerVideo = document.getElementById("scannerVideo");
    const scanStatus = document.getElementById("scanStatus");
    const scannerInstruction = document.getElementById("scannerInstruction");
    const manualCodeInput = document.getElementById("manualCode");
    const submitCodeButton = document.getElementById("submitCode");
    const cancelScanButton = document.getElementById("cancelScan");

    const defaultState = (teamId = null) => ({
      teamId,
      hasStarted: false,
      completions: Array.from({ length: PUZZLE_COUNT }, () => false),
      unlocked: Array.from({ length: PUZZLE_COUNT }, () => false),
      revealed: Array.from({ length: PUZZLE_COUNT }, () => false)
    });

    let state = loadState();
    let statusTimeoutId = null;
    let scanSession = {
      stream: null,
      detector: null,
      rafId: null,
      intent: null,
      useJsQr: false,
      canvas: null,
      canvasContext: null
    };
    let jsQrLoadPromise = null;

    const hasMediaDevices = Boolean(navigator.mediaDevices?.getUserMedia);

    initialize();

    function initialize() {
      detectPlatform();
      attachEventListeners();
      render();
    }

    function detectPlatform() {
      const ua = navigator.userAgent || "";
      const isIOS = /iPad|iPhone|iPod/.test(ua);
      const isAndroid = /Android/.test(ua);
      const isMobile = /Mobi|Android/i.test(ua);
      let label = isMobile ? "Platform: Mobile" : "Platform: Desktop";
      if (isIOS) label += " • iOS";
      if (isAndroid) label += " • Android";
      if (!hasMediaDevices) {
        label += " • Camera unavailable";
      }
      platformTag.textContent = label;
    }

    function attachEventListeners() {
      resetButton?.addEventListener("click", () => {
        if (!confirm("Reset all progress on this device?")) return;
        state = defaultState(state.teamId);
        saveState();
        render();
        showStatus("Progress reset.", "success");
      });

      exportButton?.addEventListener("click", exportProgress);
      importButton?.addEventListener("click", importProgress);

      scanButton?.addEventListener("click", () => {
        const intent = buildScanIntent();
        if (intent.mode === "complete") {
          showStatus("All missions already cleared.");
          return;
        }
        openScanner(intent);
      });

      answerForm?.addEventListener("submit", event => {
        event.preventDefault();
        submitPuzzleAnswer();
      });

      reviewProgressButton?.addEventListener("click", () => {
        progressPanel.scrollIntoView({ behavior: "smooth", block: "center" });
        showStatus("Mission queue updated.");
      });

      submitCodeButton?.addEventListener("click", () => {
        const code = manualCodeInput.value.trim();
        if (!code) {
          updateScanStatus("Enter a code before submitting.", "error");
          manualCodeInput.focus();
          return;
        }
        handleScanResult(code);
      });

      cancelScanButton?.addEventListener("click", () => {
        closeScanner("Scan cancelled.");
      });

      window.addEventListener("beforeunload", stopScannerStream);
      document.addEventListener("visibilitychange", () => {
        if (document.hidden) {
          stopScannerStream();
        }
      });
    }

    function loadState() {
      const cookieValue = getCookie(COOKIE_NAME);
      if (!cookieValue) {
        return defaultState(null);
      }
      try {
        const decoded = decodeCookieValue(cookieValue);
        const parsed = JSON.parse(decoded);
        return sanitizeState(parsed);
      } catch (err) {
        console.warn("Failed to parse cookie, resetting progress", err);
        return defaultState(null);
      }
    }

    function saveState() {
      state = sanitizeState(state);
      const payload = JSON.stringify(state);
      const maxAge = CACHE_DURATION_DAYS * 24 * 60 * 60;
      document.cookie = `${COOKIE_NAME}=${encodeURIComponent(payload)}; max-age=${maxAge}; path=/; SameSite=Lax`;
    }

    function getCookie(name) {
      const prefix = `${name}=`;
      return document.cookie
        .split(";")
        .map(entry => entry.trim())
        .find(entry => entry.startsWith(prefix))
        ?.slice(prefix.length)
        ?.replace(/^"|"$/g, "");
    }

    function decodeCookieValue(value) {
      try {
        return decodeURIComponent(value);
      } catch (err) {
        return value;
      }
    }

    function sanitizeState(candidate) {
      const fallback = defaultState(null);
      if (!candidate || typeof candidate !== "object") {
        return fallback;
      }

      let teamId = null;
      if (Number.isInteger(candidate.teamId)) {
        teamId = clampNumber(candidate.teamId, 0, TEAM_COUNT - 1);
      } else if (Number.isInteger(candidate.activeTeam)) {
        teamId = clampNumber(candidate.activeTeam, 0, TEAM_COUNT - 1);
      }

      let completions = candidate.completions;

      if (Array.isArray(candidate.progress) && candidate.progress.every(Array.isArray)) {
        const activeTeamIndex = Number.isInteger(candidate.activeTeam)
          ? clampNumber(candidate.activeTeam, 0, candidate.progress.length - 1)
          : Number.isInteger(teamId)
          ? clampNumber(teamId, 0, candidate.progress.length - 1)
          : 0;
        const source = candidate.progress[activeTeamIndex] ?? [];
        completions = source.map(Boolean);
      } else if (Array.isArray(candidate.progress)) {
        completions = candidate.progress.map(Boolean);
      }

      if (!Array.isArray(completions)) {
        completions = [];
      }

      const sanitizedCompletions = Array.from({ length: PUZZLE_COUNT }, (_, index) => Boolean(completions[index]));

      const unlockedSource = Array.isArray(candidate.unlocked) ? candidate.unlocked : [];
      const sanitizedUnlocked = Array.from({ length: PUZZLE_COUNT }, (_, index) => {
        if (sanitizedCompletions[index]) return true;
        return Boolean(unlockedSource[index]);
      });

      const revealedSource = Array.isArray(candidate.revealed) ? candidate.revealed : [];
      const sanitizedRevealed = Array.from({ length: PUZZLE_COUNT }, (_, index) => {
        if (sanitizedUnlocked[index]) return true;
        return Boolean(revealedSource[index]);
      });

      const hasStarted =
        Boolean(candidate.hasStarted) ||
        sanitizedRevealed.some(Boolean) ||
        sanitizedUnlocked.some(Boolean) ||
        sanitizedCompletions.some(Boolean);

      return {
        teamId,
        hasStarted,
        completions: sanitizedCompletions,
        unlocked: sanitizedUnlocked,
        revealed: sanitizedRevealed
      };
    }

    function clampNumber(value, min, max) {
      const n = Number.isFinite(value) ? Number(value) : min;
      return Math.min(Math.max(n, min), max);
    }

    function getTeamOrder() {
      if (!Number.isInteger(state.teamId)) {
        return [];
      }
      return TEAM_ORDERS[state.teamId]?.slice() ?? TEAM_ORDERS[0].slice();
    }

    function solvedCount() {
      return state.completions.filter(Boolean).length;
    }

    function getNextDestinationIndex() {
      if (!Number.isInteger(state.teamId)) {
        return null;
      }
      const order = getTeamOrder();
      const next = order.find(index => !state.completions[index]);
      return typeof next === "number" ? next : null;
    }

    function getCurrentSolvingIndex() {
      if (!Number.isInteger(state.teamId)) {
        return null;
      }
      const order = getTeamOrder();
      const next = order.find(index => state.unlocked[index] && !state.completions[index]);
      return typeof next === "number" ? next : null;
    }

    function getStepNumber(puzzleIndex) {
      const order = getTeamOrder();
      const position = order.indexOf(puzzleIndex);
      return position === -1 ? null : position + 1;
    }

    function buildScanIntent() {
      if (!state.hasStarted || !Number.isInteger(state.teamId)) {
        return { mode: "start" };
      }

      const currentSolving = getCurrentSolvingIndex();
      if (currentSolving !== null) {
        return { mode: "location", puzzleIndex: currentSolving, reason: "rescan" };
      }

      const nextIndex = getNextDestinationIndex();
      if (nextIndex !== null) {
        if (state.revealed[nextIndex]) {
          return { mode: "location", puzzleIndex: nextIndex, reason: "travel" };
        }
        return { mode: "locked", puzzleIndex: nextIndex };
      }

      return { mode: "complete" };
    }

    function render() {
      renderProgress();
      renderProgressList();
      renderTowerMap();
      renderPuzzle();
    }

    function renderProgress() {
      const solved = solvedCount();
      progressBar.max = PUZZLE_COUNT;
      progressBar.value = solved;
      progressCount.textContent = `${solved} / ${PUZZLE_COUNT} puzzles solved`;

      if (Number.isInteger(state.teamId)) {
        progressLabel.textContent = `${TEAM_NAMES[state.teamId]} Progress`;
      } else if (state.hasStarted) {
        progressLabel.textContent = "Progress";
      } else {
        progressLabel.textContent = "Awaiting start";
      }
    }

    function renderProgressList() {
      const order = getTeamOrder();
      progressList.innerHTML = "";

      if (!state.hasStarted || !order.length) {
        progressList.innerHTML = "<p>Scan the starting QR code to load your mission queue.</p>";
        return;
      }

      const currentDestination = getNextDestinationIndex();
      const currentSolving = getCurrentSolvingIndex();

      order.forEach((puzzleIndex, sequenceIndex) => {
        const solved = Boolean(state.completions[puzzleIndex]);
        const unlocked = Boolean(state.unlocked[puzzleIndex]);
        const revealed = Boolean(state.revealed[puzzleIndex]);

        const item = document.createElement("div");
        item.className = "progress-item";

        if (solved) {
          item.classList.add("complete");
        } else if (puzzleIndex === currentSolving || (puzzleIndex === currentDestination && revealed && !unlocked)) {
          item.classList.add("active");
        }

        const indexBadge = document.createElement("div");
        indexBadge.className = "progress-index";
        indexBadge.textContent = sequenceIndex + 1;

        const content = document.createElement("div");
        content.className = "progress-content";

        const title = document.createElement("div");
        title.textContent = revealed || solved ? puzzles[puzzleIndex].floor : "Unknown Floor";

        const status = document.createElement("div");
        status.className = "progress-status";

        if (solved) {
          status.classList.add("unlocked");
          status.textContent = "Solved";
        } else if (unlocked) {
          status.classList.add("unlocked");
          status.textContent = "Solve now";
        } else if (revealed) {
          status.classList.add("unlocked");
          status.textContent = "Travel";
        } else {
          status.classList.add("locked");
          status.textContent = "Locked";
        }

        content.append(title, status);
        item.append(indexBadge, content);
        progressList.append(item);
      });
    }

    function renderTowerMap() {
      if (!towerLevels) return;

      towerLevels.innerHTML = "";

      const hasTeam = Number.isInteger(state.teamId);
      const currentSolving = getCurrentSolvingIndex();
      const nextDestination = getNextDestinationIndex();
      const orderSet = new Set(getTeamOrder());

      for (let index = puzzles.length - 1; index >= 0; index -= 1) {
        const puzzle = puzzles[index];
        const solved = Boolean(state.completions[index]);
        const unlocked = Boolean(state.unlocked[index]);
        const revealed = Boolean(state.revealed[index]);
        const inPath = orderSet.has(index);

        let statusClass = "is-pending";
        let statusLabel = "Waiting";

        if (state.hasStarted && hasTeam && inPath) {
          statusClass = "is-locked";
          statusLabel = "Locked";

          if (solved) {
            statusClass = "is-solved";
            statusLabel = "Solved";
          } else if (currentSolving === index) {
            statusClass = "is-active";
            statusLabel = "Solve now";
          } else if (unlocked) {
            statusClass = "is-unlocked";
            statusLabel = "Solve now";
          } else if (revealed) {
            statusClass = "is-revealed";
            statusLabel = "Travel";
          } else if (nextDestination === index) {
            statusLabel = "Next";
          }
        }

        const level = document.createElement("div");
        level.className = "tower-map-level";
        level.classList.add(statusClass);

        const label = document.createElement("div");
        label.className = "tower-map-label";
        label.textContent = puzzle.floor;

        const status = document.createElement("div");
        status.className = "tower-map-status";
        status.textContent = statusLabel;

        level.append(label, status);
        towerLevels.append(level);

        if (index === 1) {
          const ground = document.createElement("div");
          ground.className = "tower-ground-line";
          towerLevels.append(ground);
        }
      }
    }

    function renderPuzzle() {
      const hasTeam = Number.isInteger(state.teamId);
      reviewProgressButton.disabled = !state.hasStarted;
      toggleWaitingAnimation(false);

      if (!state.hasStarted || !hasTeam) {
        puzzleTitle.textContent = "Awaiting Start";
        puzzleMeta.textContent = "Scan the starting QR code to receive your mission order.";
        puzzleBody.textContent = "Tap \"Scan Start Code\" when the game master signals the beginning of your run.";
        setPuzzleFeedback("");
        scanButton.disabled = false;
        scanButton.textContent = "Scan Start Code";
        toggleAnswerForm(false);
        toggleWaitingAnimation(true);
        return;
      }

      const currentSolving = getCurrentSolvingIndex();
      if (currentSolving !== null) {
        const stepNumber = getStepNumber(currentSolving) ?? 0;
        const puzzle = puzzles[currentSolving];
        puzzleTitle.textContent = puzzle.floor;
        puzzleMeta.textContent = `${TEAM_NAMES[state.teamId]} • Puzzle ${stepNumber} of ${PUZZLE_COUNT}`;
        puzzleBody.textContent = puzzle.prompt;
        setPuzzleFeedback("Enter the correct answer to unlock the next destination.");
        scanButton.disabled = false;
        scanButton.textContent = "Rescan Location QR";
        toggleAnswerForm(true);
        return;
      }

      const nextIndex = getNextDestinationIndex();
      if (nextIndex === null) {
        puzzleTitle.textContent = "Tower Run Complete";
        puzzleMeta.textContent = `${TEAM_NAMES[state.teamId]} • Mission complete`;
        puzzleBody.textContent = "Every level from the basement through Floor 11 is secure. Await further instructions or reset to replay.";
        setPuzzleFeedback("");
        scanButton.disabled = true;
        scanButton.textContent = "Scan QR Code";
        toggleAnswerForm(false);
        return;
      }

      const revealed = Boolean(state.revealed[nextIndex]);
      const stepNumber = getStepNumber(nextIndex) ?? 0;

      if (revealed) {
        const puzzle = puzzles[nextIndex];
        puzzleTitle.textContent = puzzle.floor;
        puzzleMeta.textContent = `${TEAM_NAMES[state.teamId]} • Step ${stepNumber} of ${PUZZLE_COUNT}`;
        puzzleBody.textContent = "Travel to this location and scan the onsite QR code to unlock the puzzle.";
        setPuzzleFeedback("");
        scanButton.disabled = false;
        scanButton.textContent = "Scan Location QR";
      } else {
        puzzleTitle.textContent = "Mission Locked";
        puzzleMeta.textContent = `${TEAM_NAMES[state.teamId]} • Step ${stepNumber} of ${PUZZLE_COUNT}`;
        puzzleBody.textContent = "Solve the current puzzle to discover your next destination.";
        setPuzzleFeedback("Use a GM override code here if you need to switch teams.");
        scanButton.disabled = false;
        scanButton.textContent = "Scan QR Code";
      }

      toggleAnswerForm(false);
    }

    function toggleAnswerForm(shouldShow) {
      if (!answerForm) return;

      if (shouldShow) {
        answerForm.classList.remove("is-hidden");
        if (answerInput) {
          answerInput.disabled = false;
        }
        if (answerSubmitButton) {
          answerSubmitButton.disabled = false;
        }
      } else {
        answerForm.classList.add("is-hidden");
        if (answerInput) {
          answerInput.value = "";
          answerInput.disabled = true;
        }
        if (answerSubmitButton) {
          answerSubmitButton.disabled = true;
        }
      }
    }

    function toggleWaitingAnimation(shouldShow) {
      if (!waitingAurora) return;

      if (shouldShow) {
        waitingAurora.setAttribute("aria-hidden", "false");
        waitingAurora.classList.add("is-active");
      } else {
        waitingAurora.classList.remove("is-active");
        waitingAurora.setAttribute("aria-hidden", "true");
      }
    }

    function setPuzzleFeedback(message, tone) {
      if (!puzzleFeedback) return;
      puzzleFeedback.className = "answer-feedback";
      if (tone === "success") {
        puzzleFeedback.classList.add("success");
      } else if (tone === "error") {
        puzzleFeedback.classList.add("error");
      }
      puzzleFeedback.textContent = message;
    }

    function queueNextScanFrame() {
      if (scanSession.detector) {
        scanSession.rafId = requestAnimationFrame(scanLoop);
      } else if (scanSession.useJsQr) {
        scanSession.rafId = requestAnimationFrame(scanLoopJsQr);
      }
    }

    function openScanner(intent) {
      scanSession.intent = intent ?? null;
      scannerModal.hidden = false;
      manualCodeInput.value = "";
      updateScannerInstruction(intent);
      updateScanStatus("Initializing camera…");
      startScannerStream();
    }

    function updateScannerInstruction(intent) {
      if (!scannerInstruction) {
        return;
      }

      let message = "Align the QR code inside the frame.";

      if (!intent) {
        scannerInstruction.textContent = message;
        return;
      }

      switch (intent.mode) {
        case "start":
          message = "Scan the starting QR code provided by the game master.";
          break;
        case "location":
          message = "Scan the QR code posted at this mission location.";
          break;
        case "locked":
          message = "Scan an override code from the game master or return after unlocking the next mission.";
          break;
        case "complete":
          message = "The hunt is complete, but you can still scan a GM override if needed.";
          break;
        default:
          break;
      }

      scannerInstruction.textContent = message;
    }

    async function startScannerStream() {
      stopScannerStream();

      if (!hasMediaDevices) {
        updateScanStatus("Camera unavailable. Enter the code manually.", "error");
        return;
      }

      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
        scanSession.stream = stream;
        scannerVideo.srcObject = stream;
        await scannerVideo.play();

        if (window.BarcodeDetector) {
          scanSession.detector = new window.BarcodeDetector({ formats: ["qr_code"] });
          scanSession.rafId = requestAnimationFrame(scanLoop);
          updateScanStatus("Scanning… Align the QR inside the frame.");
        } else {
          updateScanStatus("Preparing fallback scanner…");
          const jsQrReady = await loadJsQrLibrary();
          if (jsQrReady) {
            startJsQrLoop();
            updateScanStatus("Scanning… Align the QR inside the frame.");
          } else {
            updateScanStatus("QR detector unavailable. Enter the code manually.", "error");
          }
        }
      } catch (err) {
        console.error("Unable to start camera", err);
        updateScanStatus("Camera access denied. Enter the code manually.", "error");
      }
    }

    async function scanLoop() {
      if (!scanSession.detector || scannerVideo.readyState !== 4) {
        scanSession.rafId = requestAnimationFrame(scanLoop);
        return;
      }

      try {
        const barcodes = await scanSession.detector.detect(scannerVideo);
        if (barcodes.length > 0) {
          const value = barcodes[0].rawValue;
          handleScanResult(value);
          return;
        }
      } catch (err) {
        console.error("Barcode detection failed", err);
      }

      scanSession.rafId = requestAnimationFrame(scanLoop);
    }

    async function loadJsQrLibrary() {
      if (typeof window.jsQR === "function") {
        return true;
      }
      if (jsQrLoadPromise) {
        return jsQrLoadPromise;
      }

      jsQrLoadPromise = new Promise(resolve => {
        const script = document.createElement("script");
        script.src = "https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js";
        script.async = true;
        script.crossOrigin = "anonymous";
        script.onload = () => resolve(typeof window.jsQR === "function");
        script.onerror = () => resolve(false);
        document.head.appendChild(script);
      });

      const ready = await jsQrLoadPromise;
      if (!ready) {
        jsQrLoadPromise = null;
      }
      return ready;
    }

    function startJsQrLoop() {
      scanSession.detector = null;
      scanSession.useJsQr = true;

      if (!scanSession.canvas) {
        scanSession.canvas = document.createElement("canvas");
        scanSession.canvasContext =
          scanSession.canvas.getContext("2d", { willReadFrequently: true }) ||
          scanSession.canvas.getContext("2d");
      }

      if (!scanSession.canvasContext) {
        console.warn("Unable to initialise fallback QR canvas context");
        scanSession.useJsQr = false;
        return;
      }

      scanSession.rafId = requestAnimationFrame(scanLoopJsQr);
    }

    function scanLoopJsQr() {
      if (!scanSession.useJsQr) {
        return;
      }

      if (scannerVideo.readyState !== 4) {
        scanSession.rafId = requestAnimationFrame(scanLoopJsQr);
        return;
      }

      const videoWidth = scannerVideo.videoWidth || scannerVideo.clientWidth;
      const videoHeight = scannerVideo.videoHeight || scannerVideo.clientHeight;

      if (!videoWidth || !videoHeight) {
        scanSession.rafId = requestAnimationFrame(scanLoopJsQr);
        return;
      }

      const maxDimension = 480;
      const scale = Math.min(1, maxDimension / Math.max(videoWidth, videoHeight));
      const drawWidth = Math.max(1, Math.floor(videoWidth * scale));
      const drawHeight = Math.max(1, Math.floor(videoHeight * scale));

      if (scanSession.canvas.width !== drawWidth || scanSession.canvas.height !== drawHeight) {
        scanSession.canvas.width = drawWidth;
        scanSession.canvas.height = drawHeight;
      }

      scanSession.canvasContext.drawImage(scannerVideo, 0, 0, drawWidth, drawHeight);

      try {
        const imageData = scanSession.canvasContext.getImageData(0, 0, drawWidth, drawHeight);
        const detector = window.jsQR;
        if (typeof detector === "function") {
          const result = detector(imageData.data, drawWidth, drawHeight, { inversionAttempts: "dontInvert" });
          if (result?.data) {
            handleScanResult(result.data);
            return;
          }
        }
      } catch (err) {
        console.error("Fallback QR scan failed", err);
      }

      scanSession.rafId = requestAnimationFrame(scanLoopJsQr);
    }

    function handleScanResult(value) {
      const normalizedValue = normalizeCode(value);

      if (!normalizedValue) {
        updateScanStatus("Unrecognized code. Try again.", "error");
        queueNextScanFrame();
        return;
      }

      if (Object.prototype.hasOwnProperty.call(GM_TEAM_CODES, normalizedValue)) {
        handleTeamOverride(GM_TEAM_CODES[normalizedValue], value);
        return;
      }

      if (Object.prototype.hasOwnProperty.call(START_CODES, normalizedValue)) {
        handleStartCode(START_CODES[normalizedValue], value);
        return;
      }

      if (Object.prototype.hasOwnProperty.call(PUZZLE_CODE_LOOKUP, normalizedValue)) {
        handleLocationScan(PUZZLE_CODE_LOOKUP[normalizedValue]);
        return;
      }

      updateScanStatus("Code not recognized for this hunt. Check with the game master.", "error");
      queueNextScanFrame();
    }

    function handleStartCode(teamId, rawValue) {
      if (!Number.isInteger(teamId)) {
        updateScanStatus("Start code not recognized.", "error");
        queueNextScanFrame();
        return;
      }

      const result = assignTeamRun(teamId, { sourceLabel: "Start", rawValue });
      if (!result) {
        queueNextScanFrame();
      }
    }

    function handleTeamOverride(teamId, rawValue) {
      if (!Number.isInteger(teamId)) {
        updateScanStatus("Override code not recognized.", "error");
        queueNextScanFrame();
        return;
      }

      const result = assignTeamRun(teamId, { sourceLabel: "GM override", rawValue });
      if (!result) {
        queueNextScanFrame();
      }
    }

    function handleLocationScan(puzzleIndex) {
      if (!state.hasStarted || !Number.isInteger(state.teamId)) {
        updateScanStatus("Scan your starting code before visiting floors.", "error");
        queueNextScanFrame();
        return;
      }

      if (!Number.isInteger(puzzleIndex) || puzzleIndex < 0 || puzzleIndex >= PUZZLE_COUNT) {
        updateScanStatus("That QR code isn't part of this hunt.", "error");
        queueNextScanFrame();
        return;
      }

      const floorName = puzzles[puzzleIndex]?.floor ?? "This mission";

      if (state.completions[puzzleIndex]) {
        updateScanStatus(`${floorName} is already solved.`, "success");
        queueNextScanFrame();
        return;
      }

      if (state.unlocked[puzzleIndex]) {
        updateScanStatus(`${floorName} is already unlocked. Submit the answer to continue.`, "success");
        queueNextScanFrame();
        return;
      }

      const currentSolving = getCurrentSolvingIndex();
      if (currentSolving !== null && currentSolving !== puzzleIndex) {
        const activeName = puzzles[currentSolving]?.floor ?? "your current mission";
        updateScanStatus(`Finish ${activeName} before scanning another mission.`, "error");
        queueNextScanFrame();
        return;
      }

      const nextIndex = getNextDestinationIndex();
      if (nextIndex !== puzzleIndex) {
        updateScanStatus(`${floorName} isn't unlocked yet for your team.`, "error");
        queueNextScanFrame();
        return;
      }

      if (!state.revealed[puzzleIndex]) {
        updateScanStatus("That mission is still hidden. Solve the clue you already unlocked.", "error");
        queueNextScanFrame();
        return;
      }

      state.unlocked[puzzleIndex] = true;
      state.revealed[puzzleIndex] = true;
      saveState();
      render();

      closeScanner(`Location confirmed: ${floorName}.`, "success");
      showStatus(`${floorName} puzzle unlocked.`, "success");

      window.setTimeout(() => {
        if (answerInput && !answerInput.disabled) {
          answerInput.focus({ preventScroll: true });
        }
      }, 200);
    }

    function assignTeamRun(teamId, { sourceLabel = "Team" } = {}) {
      const sanitizedTeam = clampNumber(teamId, 0, TEAM_COUNT - 1);
      const existingTeam = Number.isInteger(state.teamId) ? state.teamId : null;
      const hadProgress = state.hasStarted && hasRecordedProgress();
      const sameTeamWithoutProgress = state.hasStarted && existingTeam === sanitizedTeam && !hadProgress;

      if (sameTeamWithoutProgress) {
        updateScanStatus(`Already assigned to ${TEAM_NAMES[sanitizedTeam]}.`, "success");
        return false;
      }

      state = defaultState(sanitizedTeam);
      state.hasStarted = true;
      revealNextDestination();
      saveState();
      render();

      const nextIndex = getNextDestinationIndex();
      const firstFloor = nextIndex !== null ? puzzles[nextIndex].floor : null;
      const progressNote = hadProgress ? " Previous progress cleared." : "";
      const teamName = TEAM_NAMES[sanitizedTeam];
      const statusMessage = `${teamName} mission queue ready.${firstFloor ? ` Head to ${firstFloor}.` : ""}${progressNote}`.trim();

      closeScanner(`${sourceLabel} code accepted for ${teamName}.`, "success");
      showStatus(statusMessage, "success");
      return true;
    }

    function hasRecordedProgress() {
      return state.unlocked.some(Boolean) || state.completions.some(Boolean);
    }

    function revealNextDestination() {
      const nextIndex = getNextDestinationIndex();
      if (nextIndex === null) {
        return null;
      }
      state.revealed[nextIndex] = true;
      return nextIndex;
    }

    function submitPuzzleAnswer() {
      if (!answerInput || answerInput.disabled) {
        setPuzzleFeedback("Unlock a puzzle before submitting an answer.", "error");
        return;
      }

      const solvingIndex = getCurrentSolvingIndex();
      if (solvingIndex === null) {
        setPuzzleFeedback("Unlock a puzzle before submitting an answer.", "error");
        return;
      }

      const guess = answerInput.value.trim();
      if (!guess) {
        setPuzzleFeedback("Enter an answer before submitting.", "error");
        answerInput.focus();
        return;
      }

      const puzzle = puzzles[solvingIndex];
      const normalizedGuess = normalizeAnswer(guess);
      const expectedAnswer = normalizeAnswer(puzzle.answer ?? "");

      if (expectedAnswer && normalizedGuess !== expectedAnswer) {
        setPuzzleFeedback("That answer isn't correct yet. Keep trying.", "error");
        answerInput.select();
        return;
      }

      answerInput.value = "";
      state.unlocked[solvingIndex] = true;
      state.completions[solvingIndex] = true;
      const nextIndex = revealNextDestination();
      saveState();
      render();

      const parts = [`${puzzle.floor} solved!`];
      if (nextIndex !== null) {
        parts.push(`Next mission revealed: ${puzzles[nextIndex].floor}.`);
      } else {
        parts.push("All missions complete!");
      }

      const summary = parts.join(" ");
      setPuzzleFeedback(summary, "success");
      showStatus(summary, "success");
    }

    function closeScanner(message, tone) {
      if (message) {
        updateScanStatus(message, tone);
      }
      stopScannerStream();
      scannerModal.hidden = true;
    }

    function stopScannerStream() {
      if (scanSession.rafId) {
        cancelAnimationFrame(scanSession.rafId);
        scanSession.rafId = null;
      }
      if (scanSession.stream) {
        scanSession.stream.getTracks().forEach(track => track.stop());
        scanSession.stream = null;
      }
      if (scannerVideo.srcObject) {
        scannerVideo.srcObject = null;
      }
      scanSession.detector = null;
      scanSession.useJsQr = false;
      scanSession.intent = null;
    }

    function updateScanStatus(message, tone) {
      scanStatus.textContent = message;
      scanStatus.className = "scan-status";
      if (tone === "success") {
        scanStatus.classList.add("success");
      } else if (tone === "error") {
        scanStatus.classList.add("error");
      }
    }

    function normalizeCode(value) {
      return value.trim().toUpperCase().replace(/[^A-Z0-9-]/g, "");
    }

    function normalizeAnswer(value) {
      return value.trim().toUpperCase().replace(/[^A-Z0-9]/g, "");
    }

    function showStatus(message, tone = "info") {
      if (!statusMessage) return;
      statusMessage.className = "status-message";
      if (tone === "success") {
        statusMessage.classList.add("success");
      } else if (tone === "error") {
        statusMessage.classList.add("error");
      }
      statusMessage.textContent = message;
      statusMessage.classList.add("visible");

      if (statusTimeoutId) {
        clearTimeout(statusTimeoutId);
      }
      statusTimeoutId = window.setTimeout(() => {
        statusMessage.className = "status-message";
        statusMessage.textContent = "";
        statusTimeoutId = null;
      }, 4500);
    }

    function fallbackCopyPrompt(code) {
      const promptMessage = "Progress code ready. Press Ctrl+C (Cmd+C on Mac) to copy:";
      const response = window.prompt(promptMessage, code);
      if (response !== null) {
        showStatus("Progress code ready to share.", "success");
      } else {
        showStatus("Copy cancelled.");
      }
    }

    function createShareCode(currentState) {
      const sanitized = sanitizeState(currentState);
      return btoa(JSON.stringify(sanitized));
    }

    function exportProgress() {
      const shareCode = createShareCode(state);
      if (navigator.clipboard?.writeText) {
        navigator.clipboard
          .writeText(shareCode)
          .then(() => showStatus("Copied progress code to clipboard.", "success"))
          .catch(() => {
            fallbackCopyPrompt(shareCode);
          });
        return;
      }

      fallbackCopyPrompt(shareCode);
    }

    function parseProgressInput(rawInput) {
      const trimmed = rawInput.trim();
      if (!trimmed) {
        throw new Error("No data supplied");
      }

      const cookiePattern = new RegExp(`${COOKIE_NAME}=([^;\s]+)`);
      const cookieMatch = trimmed.match(cookiePattern);
      const encoded = cookieMatch ? cookieMatch[1] : trimmed;

      const candidates = new Set([encoded]);
      const decoded = decodeCookieValue(encoded);
      candidates.add(decoded);

      try {
        candidates.add(atob(encoded));
      } catch (err) {
        // ignore
      }

      try {
        candidates.add(atob(decoded));
      } catch (err) {
        // ignore
      }

      for (const candidate of candidates) {
        if (!candidate || typeof candidate !== "string") continue;
        try {
          return JSON.parse(candidate);
        } catch (err) {
          // continue
        }
      }

      throw new Error("Unable to parse progress input");
    }

    function importProgress() {
      const input = window.prompt("Paste a progress code or cookie value to import:");
      if (input === null) {
        showStatus("Import cancelled.");
        return;
      }

      if (!input.trim()) {
        showStatus("Nothing to import. Paste a code and try again.", "error");
        return;
      }

      try {
        const parsed = parseProgressInput(input);
        state = sanitizeState(parsed);
        saveState();
        render();
        showStatus("Progress imported successfully.", "success");
      } catch (err) {
        console.error("Import failed", err);
        showStatus("Import failed. Check the code and try again.", "error");
      }
    }
  </script>
</body>
</html>
